<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>kafka安装手册</title>
    <url>/2020/03/12/kafka%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>kafka 2.11-0.9.0.1</li>
<li>zookeeper 3.4.14</li>
<li>jdk openjdk version “1.8.0_242”</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>一. Zookeeper<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvzf zookeeper-3.4.14.tar.gz</span><br><span class="line">mv zookeeper-3.4.14 /opt/</span><br><span class="line"><span class="built_in">cd</span> /opt/zookeeper-3.4.14/conf/</span><br><span class="line"><span class="comment">## 复制模板配置文件</span></span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line"><span class="comment">##### 可选，修改zoo.cfg 中的data地址</span></span><br><span class="line">dataDir=/opt/zookeeper-3.4.14/data</span><br><span class="line"><span class="comment">######</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##启动</span></span><br><span class="line"><span class="built_in">cd</span> ../bin/</span><br><span class="line">./zkServer.sh  start</span><br><span class="line"><span class="comment">## 修改环境变量，把zookeeper 地址添加进去</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="comment">######</span></span><br><span class="line">ZOOKEEPER_HOME=/opt/zookeeper-3.4.14</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ZOOKEEPER_HOME</span>/bin</span><br><span class="line"><span class="comment">######</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></p>
<p>二. Kafka<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar xvzf kafka_2.11-0.9.0.1.tgz</span><br><span class="line">mv kafka_2.11-0.9.0.1 /opt/</span><br><span class="line"><span class="built_in">cd</span> /opt/kafka_2.11-0.9.0.1/</span><br><span class="line"><span class="comment">## 运行前需要确认Zookeeper是否启动 并且修改config/server.properties 中的Zookeeper地址</span></span><br><span class="line"><span class="built_in">cd</span> bin/</span><br><span class="line">nohup kafka-server-start.sh ../config/server.properties &amp;</span><br><span class="line"><span class="comment">### 没报错为正常启动 ，否则查看 nohup文件查看错误，一般情况为内存太大</span></span><br><span class="line">vim  kafka-server-start.sh</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_HEAP_OPTS</span>"</span> = <span class="string">"x"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">"-Xmx256m -Xms128m"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">######</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改环境变量，把zookeeper 地址添加进去</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="comment">######</span></span><br><span class="line">KAFKA_HOME=/opt/kafka_2.11-0.9.0.1</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$KAFKA_HOME</span>/bin</span><br><span class="line"><span class="comment">######</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>打开两个窗口</li>
<li>窗口一为producer </li>
<li>执行<code>opt/kafka_2.11-0.9.0.1$ bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</code></li>
<li>窗口二为consumer </li>
<li>执行<code>opt/kafka_2.11-0.9.0.1$ bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning</code></li>
<li>在producer任意输入内容，查看consumer是否能正常接收，如果可以则安装完成</li>
</ul>
]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序，中序，后续遍历</title>
    <url>/2019/05/31/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>递归的做法比较简单，直接递归调用方法就行，三种方式仅仅是入队列的位置不同而已，这儿就直接贴代码了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">         List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> list;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//前序遍历</span></span><br><span class="line">         <span class="comment">//list.add(root.val);</span></span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">             List&lt;Integer&gt; list1 = inorderTraversal(root.left);</span><br><span class="line">             list.addAll(list1);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//中序遍历</span></span><br><span class="line">         list.add(root.val);</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">             List&lt;Integer&gt; list1 = inorderTraversal(root.right);</span><br><span class="line">             list.addAll(list1);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//后序遍历</span></span><br><span class="line">         <span class="comment">//list.add(root.val);</span></span><br><span class="line">        </span><br><span class="line">         <span class="keyword">return</span> list;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><ul>
<li>非递归的做法通常使用栈的方式处理，后续会比较麻烦一点，我们一个个来。<ol>
<li>前序遍历</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal_2</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//前序遍历的顺序是《根左右》</span></span><br><span class="line">         List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         TreeNode temp = root;</span><br><span class="line">         Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">         <span class="keyword">while</span> (temp != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">             <span class="comment">//节点非空就入栈</span></span><br><span class="line">             <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">//根节点先直接输出</span></span><br><span class="line">                 list.add(temp.val);</span><br><span class="line">                 stack.push(temp);</span><br><span class="line">                 <span class="comment">//一路往左子树深入</span></span><br><span class="line">                 temp = temp.left;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//开始弹出堆栈，处理右子树</span></span><br><span class="line">             <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                 temp = stack.pop();</span><br><span class="line">                 temp = temp.right;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">return</span> list;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>中序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal_2</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//前序遍历的顺序是《左根右》</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    TreeNode temp = root;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//一路往左子树深入</span></span><br><span class="line">            stack.push(temp);</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//弹出最后一个左子树的节点</span></span><br><span class="line">            temp = stack.pop();</span><br><span class="line">            <span class="comment">//输出当前值</span></span><br><span class="line">            list.add(temp.val);</span><br><span class="line">            <span class="comment">//往当前节点的右子树深入</span></span><br><span class="line">            temp = temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>后序遍历</p>
<ul>
<li>堆栈做法，因为是《左右根》的顺序，所以堆栈出栈的时候会调用两次，第一次完成左子树的遍历，到节点，此时该节点临时保存下，不输出，重新入栈，然后继续往该节点的右子树进行遍历，直到下一次临时节点等于栈顶，代表该节点的右子树也遍历完毕，此时再将节点的值进行输出</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 描述 后序遍历 非递归</span></span><br><span class="line"><span class="comment">      * 左边到最底层-》第一次出栈-》右边到最底层-》第二次出栈-》记录</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> java.util.List&lt;java.lang.Integer&gt;</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@author</span> Ted Wang</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@created</span> 2019/5/27 15:02</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">         TreeNode temp = root;</span><br><span class="line">         TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//走到左子树最底层</span></span><br><span class="line">         <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">             stack.push(temp);</span><br><span class="line">             temp = temp.left;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">             temp = stack.pop();</span><br><span class="line">             <span class="keyword">if</span> (temp.right != <span class="keyword">null</span> &amp;&amp; !temp.right.equals(last)) &#123;</span><br><span class="line">                 stack.push(temp);</span><br><span class="line">                 temp = temp.right;</span><br><span class="line">                 <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//走到右子树的最左边</span></span><br><span class="line">                     stack.push(temp);</span><br><span class="line">                     temp = temp.left;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//没有右子树或者右子树已经遍历完成，输出该节点</span></span><br><span class="line">                 list.add(temp.val);</span><br><span class="line">                 last = temp;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> list;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>逆序做法，因为<strong>前序遍历</strong> 是 《根 左 右》，而 <strong>后序遍历</strong>是 《左 右 根》，所以只需要把<strong>前序遍历</strong>的遍历顺序改为《根 右 左》此时就正好是<strong>后续遍历</strong>的逆序遍历，把输出结果逆序输出就行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 描述 后序遍历 非递归</span></span><br><span class="line"><span class="comment">      * 前序 :根左右 改成 根右左 =》逆序 左右根（后序遍历）</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> java.util.List&lt;java.lang.Integer&gt;</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@author</span> Ted Wang</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@created</span> 2019/5/27 15:02</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal2</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         TreeNode temp = root;</span><br><span class="line">         Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">         <span class="keyword">while</span> (temp != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">             <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 list.add(temp.val);</span><br><span class="line">                 stack.push(temp);</span><br><span class="line">                 temp = temp.right;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                 temp = stack.pop();</span><br><span class="line">                 temp = temp.left;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         Collections.reverse(list);</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">return</span> list;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 描述 后序遍历 非递归 </span></span><br><span class="line"><span class="comment">      * 前序 :根左右 改成 根右左 =》逆序 左右根（后序遍历）</span></span><br><span class="line"><span class="comment">      * 思路和上面的方法一致，只是list在保存的时候直接逆序保存</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> java.util.List&lt;java.lang.Integer&gt;</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@author</span> Ted Wang</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@created</span> 2019/5/27 15:02</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal3</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         TreeNode temp = root;</span><br><span class="line">         Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">         stack.push(root);</span><br><span class="line">         <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">             temp = root;</span><br><span class="line">             list.add(<span class="number">0</span>, temp.val);</span><br><span class="line">              <span class="keyword">if</span> (temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  stack.push(temp.left);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  stack.push(temp.right);</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/05/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
